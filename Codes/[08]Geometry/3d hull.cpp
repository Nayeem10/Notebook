#define LD long double const LD EPS = 1e-9; const LD PI = acos(-1); LD Sq(LD x) {return x * x;} LD Acos(LD x){return acos(min(1.0L,max(-1.0L,x)));} LD Asin(LD x){return asin(min(1.0L,max(-1.0L,x)));} LD Sqrt(LD x) {return sqrt(max(0.0L, x));} int dcmp(LD x) { if(fabs(x) < EPS) return 0; return (x > 0.0 ? +1 : -1); } struct Point3 { LD x, y, z; Point3() {} Point3(LD a, LD b, LD c) : x(a), y(b), z(c){} void operator=(const Point3& a) { x=a.x,y=a.y,z=a.z; } Point3 operator+(Point3 a) { Point3 p{x + a.x, y + a.y, z + a.z}; return p; } Point3 operator-(Point3 a) { Point3 p{x - a.x, y - a.y, z - a.z}; return p; } Point3 operator*(LD a) { return Point3(x*a,y*a,z*a); } Point3 operator/(LD a) { assert(a > EPS); Point3 p{x/a, y/a, z/a}; return p; } LD& operator[](int a) { if (a == 0) return x; if (a == 1) return y; if (a == 2) return z; assert(false); } bool IsZero() { return abs(x)<EPS&& abs(y)<EPS && abs(z) < EPS; } bool operator==(Point3 a) { return (*this - a).IsZero(); } LD dot(Point3 a) { return x * a.x + y * a.y + z * a.z; } LD Norm() { return Sqrt(x * x + y * y + z * z); } LD SqNorm() { return x * x + y * y + z * z; } void NormalizeSelf() { *this = *this/Norm(); } Point3 Normalize() { Point3 res(*this); res.NormalizeSelf(); return res; } LD Dis(Point3 a) { return (*this - a).Norm(); } pair<LD, LD> SphericalAngles() { return {atan2(z,Sqrt(x*x+y*y)),atan2(y,x)}; } LD Area(Point3 p) { return Norm() * p.Norm() * sin(Angle(p)) / 2; } /* LD Angle(Point3 p) { LD a = Norm(), b = p.Norm(), c = Dis(p); return Acos((a*a+b*b-c*c)/(2*a*b)); } */ LD Angle(Point3 b) { Point3 a(*this); return Acos(abs(a.dot(b))/a.Norm()/b.Norm()); } LD Angle(Point3 p, Point3 q){return p.Angle(q);} Point3 cross(Point3 p) { Point3 q(*this); return {q[1]*p[2] - q[2]*p[1], q[2]*p[0] - q[0] * p[2], q[0] * p[1] - q[1] * p[0]}; } bool LexCmp(Point3& a, const Point3& b) { if (abs(a.x - b.x) > EPS) { return a.x < b.x;} if (abs(a.y - b.y) > EPS) { return a.y < b.y;} return a.z < b.z; } }; typedef vector<Point3> face; typedef vector<Point3> edge; typedef vector<face> hull; #define INSIDE (-1) #define ON (0) #define OUTSIDE (1) int side(Point3 a, Point3 b, Point3 c, Point3 p){ Point3 norm = (b-a).cross(c-a); Point3 me = p-a; return dcmp(me.dot(norm)); } hull find_hull(vector<Point3> P) { random_shuffle(P.begin(), P.end()); int n = P.size(); for(int j = 2; j < n; j++) { Point3 n = (P[1]-P[0]).cross(P[j]-P[0]); if(n.Norm() > EPS) {swap(P[j], P[2]);break;} } for(int j = 3; j < n; j++) { if(side(P[0],P[1],P[2],P[j])) { swap(P[j], P[3]); break; } } if(side(P[0],P[1],P[2],P[3]) == OUTSIDE) swap(P[0], P[1]); hull H{ {P[0],P[1],P[2]}, {P[0],P[3],P[1]}, {P[0],P[2],P[3]},{P[3],P[2],P[1]}}; auto make_degrees = [&](const hull& H) { map<edge,int> ans; for(const auto & f : H) { for(int i = 0; i < 3; i++){ Point3 a = f[i], b = f[(i+1)%3]; ans[{a,b}]++; } } return ans; }; for(int j = 4; j < n; j++) { hull H2; H2.reserve((int)H.size()); vector<face> plane; for(const auto & f : H) { int s = side(f[0],f[1],f[2],P[j]); if (s == INSIDE || s == ON) H2.push_back(f); } /* //For any edge that now only has 1 incident //face (it's other face deleted) add a new //face with this vertex and that edge. */ map<edge, int> D = make_degrees(H2); const auto tmp = H2; for (const auto & f : tmp) { for(int i = 0; i < 3; i++) { Point3 a = f[i], b = f[(i+1)%3]; int d = D[{a,b}] + D[{b,a}]; if (d==1) H2.push_back({a, P[j], b}); } } H = H2; } return H; }