template<int MOD> struct ModInt { private: int r; static ModInt Pow(ModInt x, size_t n) { ModInt ret = 1; for (; n; n >>= 1, x *= x) if (n & 1) ret *= x; return ret; } public: constexpr ModInt() : r(0) {} constexpr ModInt(int x) : r(x % MOD) { if (r < 0) r += MOD; } constexpr ModInt(i64 x) : r(x % MOD) { if (r < 0) r += MOD; } ModInt Inv() const { return Pow(*this, MOD - 2); } ModInt operator- () const { return r ? MOD - r : 0; } ModInt operator+ (const ModInt& x) const { return ModInt(*this) += x; } ModInt operator- (const ModInt& x) const { return ModInt(*this) -= x; } ModInt operator* (const ModInt& x) const { return ModInt(*this) *= x; } ModInt operator/ (const ModInt& x) const { return ModInt(*this) /= x; } ModInt operator+= (const ModInt& x) { r += x.r; if (r >= MOD) r -= MOD; return *this; } ModInt operator-= (const ModInt& x) { r -= x.r; if (r < 0) r += MOD; return *this; } ModInt operator*= (const ModInt& x) { r = (i64)r * x.r % MOD; return *this; } ModInt operator/= (const ModInt& x) { return *this *= x.Inv(); } bool operator== (const ModInt& x) const { return r == x.r; } bool operator!= (const ModInt& x) const { return r != x.r; } operator int() const { return r; } operator i64() const { return r; } friend istream& operator>> (istream& in, ModInt& x) { i64 t; cin >> t; x = ModInt(t); return in; } friend ostream& operator<< (ostream& out, const ModInt& x) { return out << x.r; } }; using mint = ModInt<998'244'353>; /* Linear Sieve, O(n) */ vector<int> PrimeEnumerate(int n) { vector<int> P; vector<bool> B(n + 1, 1); for (int i = 2; i <= n; i++) { if (B[i]) P.push_back(i); for (int j : P) { if (i * j > n) break; B[i * j] = 0; if (i % j == 0) break; } } return P; } template<typename T> void MultipleZetaTransform(vector<T>& v) { const int n = (int)v.size() - 1; for (int p : PrimeEnumerate(n)) { for (int i = n / p; i; i--) v[i] += v[i * p]; } } template<typename T> void MultipleMobiusTransform(vector<T>& v) { const int n = (int)v.size() - 1; for (int p : PrimeEnumerate(n)) { for (int i = 1; i * p <= n; i++) v[i] -= v[i * p]; } } template<typename T> vector<T> GCDConvolution(vector<T> A, vector<T> B) { MultipleZetaTransform(A); MultipleZetaTransform(B); for (int i = 0; i < A.size(); i++) A[i] *= B[i]; MultipleMobiusTransform(A); return A; }